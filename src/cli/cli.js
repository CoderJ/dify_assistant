#!/usr/bin/env node
/**
 * dify-dsl-cli
 * 
 * ‰∏Ä‰∏™Áî®‰∫éÂØºÂÖ•ÂØºÂá∫ Dify Â∫îÁî® DSL ÈÖçÁΩÆÁöÑÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑ÔºåÊñπ‰æøÊú¨Âú∞ÁºñËæëÂíåÊâπÈáèÁÆ°ÁêÜ Dify Â∫îÁî®„ÄÇ
 * 
 * Áî®Ê≥ïÔºö
 *   node cli.js export   # ÂØºÂá∫ DSL
 *   node cli.js import   # ÂØºÂÖ• DSL
 *
 * ÈÖçÁΩÆËØ∑ÂèÇËÄÉ config.json
 */
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const axios = require('axios');
const TokenManager = require('../utils/token-manager');

// Ëß£ÊûêÂëΩ‰ª§Ë°åÂèÇÊï∞
const args = process.argv.slice(2);
const command = args[0];
const configArgIdx = args.indexOf('--config');
const configFile = configArgIdx !== -1 ? args[configArgIdx + 1] : 'config.json';

// Ëé∑ÂèñÂ∫îÁî®Ë∑ØÂæÑÔºà‰ªéÁéØÂ¢ÉÂèòÈáèÊàñÂΩìÂâçÁõÆÂΩïÔºâ
const appPath = process.env.APP_PATH || process.cwd();
const rootConfigPath = path.join(process.cwd(), 'config.json');

const tokenManager = new TokenManager();

// Á°Æ‰øùÁºìÂ≠òÊñá‰ª∂ÂßãÁªàÂú®È°πÁõÆÊ†πÁõÆÂΩï
function findProjectRoot() {
  let currentDir = process.cwd();
  console.log(`üîç ÂºÄÂßãÊü•ÊâæÈ°πÁõÆÊ†πÁõÆÂΩïÔºåÂΩìÂâçÁõÆÂΩï: ${currentDir}`);
  while (currentDir !== path.dirname(currentDir)) {
    console.log(`üîç Ê£ÄÊü•ÁõÆÂΩï: ${currentDir}`);
    const configPath = path.join(currentDir, 'config.json');
    if (fs.existsSync(configPath)) {
      try {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        // Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ÂÖ®Â±ÄÈÖçÁΩÆÔºàDIFY_BASE_URLÔºâ
        if (config.DIFY_BASE_URL) {
          console.log(`‚úÖ ÊâæÂà∞È°πÁõÆÊ†πÁõÆÂΩï: ${currentDir}`);
          return currentDir;
        }
      } catch (e) {
        // ÂøΩÁï•Ëß£ÊûêÈîôËØØ
      }
    }
    currentDir = path.dirname(currentDir);
  }
  console.log(`‚ö†Ô∏è Êú™ÊâæÂà∞È°πÁõÆÊ†πÁõÆÂΩïÔºå‰ΩøÁî®ÂΩìÂâçÁõÆÂΩï: ${process.cwd()}`);
  return process.cwd(); // Â¶ÇÊûúÊâæ‰∏çÂà∞ÔºåËøîÂõûÂΩìÂâçÁõÆÂΩï
}

const projectRoot = findProjectRoot();
const LAST_PROJECT_FILE = path.join(projectRoot, '.last_project');

function getLastProjectPath() {
  if (fs.existsSync(LAST_PROJECT_FILE)) {
    return fs.readFileSync(LAST_PROJECT_FILE, 'utf-8').trim();
  }
  return null;
}

function setLastProjectPath(projectPath) {
  console.log(`üíæ ÁºìÂ≠òÈ°πÁõÆË∑ØÂæÑ: ${projectPath}`);
  console.log(`üìÅ ÁºìÂ≠òÊñá‰ª∂‰ΩçÁΩÆ: ${LAST_PROJECT_FILE}`);
  fs.writeFileSync(LAST_PROJECT_FILE, projectPath, 'utf-8');
  console.log(`‚úÖ È°πÁõÆË∑ØÂæÑÂ∑≤ÁºìÂ≠òÂà∞: ${LAST_PROJECT_FILE}`);
}

// Á´ãÂç≥ÁºìÂ≠òÂΩìÂâçÈ°πÁõÆË∑ØÂæÑÔºàÂè™ÊúâÂú®Â∫îÁî®ÁõÆÂΩï‰∏ãÊâçÁºìÂ≠òÔºâ
if (appPath !== projectRoot) {
  setLastProjectPath(appPath);
}

// ËØªÂèñÂÖ®Â±ÄÈÖçÁΩÆ
let globalConfig = {};
try {
  globalConfig = JSON.parse(fs.readFileSync(rootConfigPath, 'utf-8'));
} catch (e) {
  console.error('ËØ∑Âú®È°πÁõÆÊ†πÁõÆÂΩïÂàõÂª∫ config.json ÂÖ®Â±ÄÈÖçÁΩÆÊñá‰ª∂ÔºÅ');
  process.exit(1);
}

// ËØªÂèñappÈÖçÁΩÆ
let appConfig = {};
try {
  const configPath = path.join(appPath, configFile);
  console.log(`üìÅ ËØªÂèñÈÖçÁΩÆÊñá‰ª∂: ${configPath}`);
  appConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  console.log('üìã ËØªÂèñÂà∞ÁöÑappConfig:', appConfig);
} catch (e) {
  console.error('‚ùå ËØªÂèñappÈÖçÁΩÆÂ§±Ë¥•:', e.message);
  // ÂøΩÁï•ÔºåÈÉ®ÂàÜÂëΩ‰ª§ÂèØËÉΩ‰∏çÈúÄË¶Å
}

const APP_ID = appConfig.APP_ID || '';
const TEST_API_KEY = appConfig.TEST_API_KEY || '';
const DIFY_BASE_URL = globalConfig.DIFY_BASE_URL;
const TEST_BASE_URL = globalConfig.TEST_BASE_URL;

console.log('üîç Ëß£ÊûêÁªìÊûú:');
console.log('  APP_ID:', APP_ID);
console.log('  TEST_API_KEY:', TEST_API_KEY ? TEST_API_KEY.substring(0, 10) + '...' : '');
console.log('  DIFY_BASE_URL:', DIFY_BASE_URL);
console.log('  TEST_BASE_URL:', TEST_BASE_URL);

// ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂèòÈáèÂêç
const api_key = TEST_API_KEY;
const api_base_url = DIFY_BASE_URL; // ËøôÈáåÂ∫îËØ•ÊòØDIFY_BASE_URLÔºå‰∏çÊòØTEST_BASE_URL

async function getToken() {
  return await tokenManager.getToken();
}

async function requestWithTokenRetry(axiosConfig) {
  return await tokenManager.requestWithTokenRetry(axiosConfig);
}

// Â∑•ÂÖ∑ÂáΩÊï∞
function safeFileName(name) {
  return name.replace(/[^\w\u4e00-\u9fa5-]+/g, '_');
}
function parsePromptMd(md) {
  // ÊîØÊåÅÂ§öË°åÂÜÖÂÆπÔºå---ÂàÜÈöî
  const blocks = md.split(/---\s*\n?/).map(b => b.trim()).filter(Boolean);
  const prompts = [];
  for (const block of blocks) {
    // ÊîØÊåÅ**role**:ÔºàÂÜíÂè∑ÂêéÂèØÊúâÁ©∫Ê†ºÔºâÔºåÂÜÖÂÆπÂèØÂ§öË°å
    const match = block.match(/^\*\*(.+?)\*\*:\s*\n?([\s\S]*)$/);
    if (match) {
      prompts.push({ role: match[1].trim(), text: match[2].trim() });
    }
  }
  return prompts;
}

// 1. ÂØºÂá∫‰∏ªDSLÂπ∂ÊãÜÂàÜllmËäÇÁÇπ
async function exportAndSplit() {
  // ÂØºÂá∫‰∏ªDSL
  try {
    const requestUrl = `${api_base_url}/console/api/apps/${APP_ID}/export?include_secret=false`;
    console.log(`üîó ËØ∑Ê±ÇURL: ${requestUrl}`);
    console.log(`üìã APP_ID: ${APP_ID}`);
    console.log(`üåê API_BASE_URL: ${api_base_url}`);
    
    const res = await requestWithTokenRetry({
      method: 'get',
      url: requestUrl
    });
    const dslDir = path.join(appPath, 'DSL');
    if (!fs.existsSync(dslDir)) fs.mkdirSync(dslDir);
    let yamlContent = res.data;
    if (typeof yamlContent === 'object' && yamlContent.data) yamlContent = yamlContent.data;
    const mainPath = path.join(dslDir, 'main.yml');
    fs.writeFileSync(mainPath, yamlContent, 'utf-8');
    console.log('ÂØºÂá∫ÊàêÂäüÔºåÊñá‰ª∂Â∑≤‰øùÂ≠ò‰∏∫ DSL/main.yml');
    // ÊãÜÂàÜllmËäÇÁÇπ
    const promptsDir = path.join(appPath, 'prompts');
    if (!fs.existsSync(promptsDir)) fs.mkdirSync(promptsDir);
    const dsl = yaml.load(fs.readFileSync(mainPath, 'utf-8'));
    const nodes = dsl?.workflow?.graph?.nodes || [];
    // Ëá™Âä®ÁîüÊàêinputs.json
    const testDir = path.join(appPath, 'test');
    if (!fs.existsSync(testDir)) fs.mkdirSync(testDir);
    const inputsPath = path.join(testDir, 'inputs.json');
    const startNode = nodes.find(n => n.data?.type === 'start');
    const variables = (startNode?.data?.variables || []).filter(v => v.required);
    const inputs = {};
    for (const v of variables) {
      if (v.type === 'number') inputs[v.variable] = 0;
      else if (v.type === 'text-input') inputs[v.variable] = '';
      else inputs[v.variable] = null;
    }
    fs.writeFileSync(inputsPath, JSON.stringify(inputs, null, 2), 'utf-8');
    console.log('Â∑≤ÁîüÊàê test/inputs.json:', inputs);
    // Ëá™Âä®ÁîüÊàêinputs/1/ÂèòÈáètxtÊ®°Êùø
    const inputsDir = path.join(testDir, 'inputs', '1');
    if (!fs.existsSync(inputsDir)) fs.mkdirSync(inputsDir, { recursive: true });
    for (const v of variables) {
      const varFile = path.join(inputsDir, `${v.variable}.txt`);
      if (!fs.existsSync(varFile)) fs.writeFileSync(varFile, '');
    }
    console.log('Â∑≤ÁîüÊàê test/inputs/1/ ‰∏ãÁöÑÂèòÈáètxtÊ®°ÊùøÔºåÂèØÁõ¥Êé•Á≤òË¥¥Â§ßÊÆµÊñáÊú¨„ÄÇ');
    // ÊãÜÂàÜllmËäÇÁÇπ
    let llmCount = 0;
    for (const node of nodes) {
      if (node?.data?.type === 'llm') {
        const title = node.data.title || `llm_${node.id}`;
        const safeTitle = safeFileName(title);
        // prompt_template -> Â§ömdÊñá‰ª∂
        const prompts = node.data.prompt_template || [];
        for (let i = 0; i < prompts.length; i++) {
          const role = prompts[i].role;
          const fileName = `${safeTitle}.${role}.md`;
          fs.writeFileSync(path.join(promptsDir, fileName), prompts[i].text, 'utf-8');
        }
        // ÂÖ∂ÂÆÉÂèÇÊï∞ -> json
        const { prompt_template, ...rest } = node.data;
        fs.writeFileSync(path.join(promptsDir, `${safeTitle}.json`), JSON.stringify(rest, null, 2), 'utf-8');
        llmCount++;
        console.log(`Â∑≤ÂØºÂá∫: ${safeTitle}.[role].md, ${safeTitle}.json`);
      }
    }
    if (llmCount === 0) {
      console.log('Êú™ÊâæÂà∞‰ªª‰Ωï llm ËäÇÁÇπ„ÄÇ');
    } else {
      console.log(`ÂÖ±ÂØºÂá∫ ${llmCount} ‰∏™ llm ËäÇÁÇπ„ÄÇ`);
    }
  } catch (err) {
    console.error('ÂØºÂá∫ÊàñÊãÜÂàÜÂ§±Ë¥•:', err.response ? err.response.data : err.message);
    process.exit(1);
  }
}

// 2. ÂêàÂπ∂llmËäÇÁÇπÂπ∂ÂØºÂÖ•+ÂèëÂ∏É
async function mergeAndUpdate() {
  // Ê£ÄÊü•ÊòØÂê¶‰∏∫PRODUCTIONÊ†áÁ≠æÁöÑÂ∫îÁî®
  const appName = path.basename(appPath);
  if (appName.includes('-PRODUCTION-')) {
    console.error('‚ùå ÂÆâÂÖ®ÈôêÂà∂ÔºöÊ£ÄÊµãÂà∞PRODUCTIONÊ†áÁ≠æÁöÑÂ∫îÁî®Ôºå‰∏çÂÖÅËÆ∏ÊâßË°åupdateÊìç‰ΩúÔºÅ');
    console.error('üìù Â∫îÁî®ÂêçÁß∞:', appName);
    console.error('üîí ‰∏∫‰∫Ü‰øùÊä§Áîü‰∫ßÁéØÂ¢ÉÔºåPRODUCTIONÊ†áÁ≠æÁöÑÂ∫îÁî®Á¶ÅÊ≠¢updateÊìç‰Ωú');
    console.error('üí° Â¶ÇÈúÄÊõ¥Êñ∞ÔºåËØ∑ÂÖàÂ∞ÜÂ∫îÁî®Ê†áÁ≠æÊîπ‰∏∫TESTÔºåÊàñËÅîÁ≥ªÁÆ°ÁêÜÂëò');
    process.exit(1);
  }

  // ÂêàÂπ∂llmËäÇÁÇπ
  const dslPath = path.join(appPath, 'DSL', 'main.yml');
  const promptsDir = path.join(appPath, 'prompts');
  const dsl = yaml.load(fs.readFileSync(dslPath, 'utf-8'));
  const nodes = dsl?.workflow?.graph?.nodes || [];
  let llmCount = 0;
  for (const node of nodes) {
    if (node?.data?.type === 'llm') {
      const title = node.data.title || `llm_${node.id}`;
      const safeTitle = safeFileName(title);
      const jsonPath = path.join(promptsDir, `${safeTitle}.json`);
      if (!fs.existsSync(jsonPath)) {
        console.warn(`Ë∑≥Ëøá ${title}ÔºåÂõ†Áº∫Â∞ë json Êñá‰ª∂„ÄÇ`);
        continue;
      }
      // ËØªÂèñÊâÄÊúâ .role.md Êñá‰ª∂
      const prompt_template = [];
      const files = fs.readdirSync(promptsDir).filter(f => f.startsWith(`${safeTitle}.`) && f.endsWith('.md'));
      for (const file of files) {
        const m = file.match(/^.+\.(.+)\.md$/);
        if (m) {
          const role = m[1];
          const text = fs.readFileSync(path.join(promptsDir, file), 'utf-8');
          prompt_template.push({ role, text });
        }
      }
      // ÊåâÂ∏∏ËßÅÈ°∫Â∫èÊéíÂ∫èÔºàsystem, user, assistant, ...Ôºâ
      const roleOrder = { system: 1, user: 2, assistant: 3 };
      prompt_template.sort((a, b) => (roleOrder[a.role] || 99) - (roleOrder[b.role] || 99));
      const rest = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));
      node.data = { ...rest, prompt_template };
      llmCount++;
      console.log(`Â∑≤ÂêàÂπ∂: ${safeTitle}`);
    }
  }
  fs.writeFileSync(dslPath, yaml.dump(dsl, { lineWidth: 120 }), 'utf-8');
  console.log(`Â∑≤ÁîüÊàêÊñ∞ÁöÑ main.ymlÔºållm ËäÇÁÇπÂÖ±ÂêàÂπ∂ ${llmCount} ‰∏™„ÄÇ`);
  // ÂØºÂÖ•+ÂèëÂ∏É
  try {
    const yamlContent = fs.readFileSync(dslPath, 'utf-8');
    const res = await requestWithTokenRetry({
      method: 'post',
      url: `${api_base_url}/console/api/apps/imports`,
      data: {
        mode: 'yaml-content',
        yaml_content: yamlContent,
        app_id: APP_ID
      },
      headers: {
        'Content-Type': 'application/json'
      }
    });
    console.log('ÂØºÂÖ•ÊàêÂäü:', res.data);
    // Ëá™Âä®ÂèëÂ∏É
    const publishRes = await requestWithTokenRetry({
      method: 'post',
      url: `${api_base_url}/console/api/apps/${APP_ID}/workflows/publish`,
      data: { marked_name: '', marked_comment: '' },
      headers: {
        'Content-Type': 'application/json'
      }
    });
    console.log('ÂèëÂ∏ÉÊàêÂäü:', publishRes.data);
  } catch (err) {
    console.error('ÂØºÂÖ•ÊàñÂèëÂ∏ÉÂ§±Ë¥•:', err.response ? err.response.data : err.message);
    process.exit(1);
  }
}

// ÂëΩ‰ª§ÂàÜÂèë
if (command === 'export') {
  exportAndSplit().then(() => {
    setLastProjectPath(appPath);
  });
} else if (command === 'update') {
  mergeAndUpdate().then(() => {
    setLastProjectPath(appPath);
  });
} else {
  // ÊîØÊåÅ --select ÂèÇÊï∞Âº∫Âà∂ÈáçÊñ∞ÈÄâÊã©
  if (!args.includes('--select')) {
    const lastProject = getLastProjectPath();
    console.log(`üîç Ê£ÄÊü•Ëá™Âä®ÂàáÊç¢: lastProject=${lastProject}, appPath=${appPath}`);
    if (lastProject && lastProject !== appPath) {
      console.log(`üîÑ Ëá™Âä®ÂàáÊç¢Âà∞‰∏äÊ¨°Ë∞ÉËØïÁöÑÈ°πÁõÆ: ${lastProject}`);
      process.chdir(lastProject);
      // Ëá™Âä®ÊâßË°å exportÔºå‰ΩøÁî®Áõ∏ÂØπ‰∫éÈ°πÁõÆÊ†πÁõÆÂΩïÁöÑË∑ØÂæÑ
      const cliPath = path.relative(lastProject, path.join(projectRoot, 'src', 'cli', 'cli.js'));
      require('child_process').execSync(`node ${cliPath} export`, { stdio: 'inherit' });
      process.exit(0);
    } else {
      console.log(`‚ÑπÔ∏è Êó†ÈúÄÂàáÊç¢: lastProject=${lastProject}, appPath=${appPath}`);
    }
  }
  console.log('Áî®Ê≥ï: node cli.js export|update [--config config.test.json]');
  process.exit(1);
} 